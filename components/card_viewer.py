from collections import defaultdict, deque

import streamlit as st
from pokemontcgsdk import Card

from utils.storage import remove_one_card_from_collection

# Code generated by OpenAI's ChatGPT o1-preview
def group_evolution_families(pokemon: dict[str, tuple[Card, int]]) -> dict[str, list[tuple[Card, int]]]:
    # Step 1: Build a mapping from card names to card IDs
    name_to_card_ids = defaultdict(list)
    for card_id, (card, qty) in pokemon.items():
        name_to_card_ids[card.name].append(card_id)

    # Step 2: Build an undirected graph where nodes are card IDs
    graph = {card_id: set() for card_id in pokemon}
    for card_id, (card, qty) in pokemon.items():
        if card.evolvesFrom:
            evolves_from_name = card.evolvesFrom
            # Connect current card to all cards it evolves from
            for parent_card_id in name_to_card_ids.get(evolves_from_name, []):
                graph[card_id].add(parent_card_id)
                graph[parent_card_id].add(card_id)

    # Step 3: Find connected components in the graph
    visited = set()
    components = []
    for card_id in graph:
        if card_id not in visited:
            stack = [card_id]
            component = []
            while stack:
                current_id = stack.pop()
                if current_id not in visited:
                    visited.add(current_id)
                    component.append(current_id)
                    stack.extend(graph[current_id] - visited)
            components.append(component)

    # Step 4: Group cards into evolution families and sort them by evolution stages
    evolution_families = {}
    for component in components:
        family_card_ids = component

        # Build a mapping from card_id to its children within the family
        children = {card_id: [] for card_id in family_card_ids}
        for card_id in family_card_ids:
            card, qty = pokemon[card_id]
            if card.evolvesFrom:
                evolves_from_name = card.evolvesFrom
                # Connect current card to its parent(s) within the family
                for parent_card_id in name_to_card_ids.get(evolves_from_name, []):
                    if parent_card_id in family_card_ids:
                        children[parent_card_id].append(card_id)

        # Find roots (basic Pokémon)
        roots = []
        for card_id in family_card_ids:
            card = pokemon[card_id][0]
            if not card.evolvesFrom or not any(
                    parent_card_id in family_card_ids for parent_card_id in name_to_card_ids.get(card.evolvesFrom, [])
            ):
                roots.append(card_id)

        # Assign levels using BFS
        queue = deque([(card_id, 0) for card_id in roots])
        card_levels = {}  # card_id -> level
        visited_levels = set()
        while queue:
            card_id, level = queue.popleft()
            if card_id in visited_levels:
                continue
            visited_levels.add(card_id)
            card_levels[card_id] = level
            for child_id in children[card_id]:
                queue.append((child_id, level + 1))

        # Sort the cards by their levels
        sorted_card_ids = sorted(card_levels, key=lambda x: card_levels[x])

        # Gather the sorted cards
        family_cards = [(pokemon[card_id][0], pokemon[card_id][1]) for card_id in sorted_card_ids]

        # Attempt to find a basic Pokémon to name the family
        basic_cards = [pokemon[card_id][0] for card_id in roots]
        if basic_cards:
            family_name = basic_cards[0].name
        else:
            # Use the first card's name if no basic Pokémon is found
            family_name = family_cards[0][0].name
        # Ensure the family name is unique
        original_family_name = family_name
        index = 1
        while family_name in evolution_families:
            family_name = f"{original_family_name}_{index}"
            index += 1
        evolution_families[family_name] = family_cards

    return evolution_families


# Function to sort cards
def sort_cards(cards_dict: dict[str, tuple[Card, int]]) -> list[tuple[Card, int]]:
    type_sort_order = [
        "Colorless",
        "Darkness",
        "Dragon",
        "Fairy",
        "Fighting",
        "Fire",
        "Grass",
        "Lightning",
        "Metal",
        "Psychic",
        "Water",
    ]

    # Helper function to get type index
    def get_type_index(c: Card) -> int:
        if c.types and c.types[0] in type_sort_order:
            return type_sort_order.index(c.types[0])
        return len(type_sort_order)  # Place unknown types at the end

    # Separate Pokémon, Trainers, and Energies
    pokemon = {k: v for k, v in cards_dict.items() if v[0].supertype == "Pokémon"}
    trainers = {k: v for k, v in cards_dict.items() if v[0].supertype == "Trainer"}
    energies = {k: v for k, v in cards_dict.items() if v[0].supertype == "Energy"}

    # Group Pokémon by evolution family
    evolution_families = group_evolution_families(pokemon)

    # Sort Pokémon families by type
    sorted_pokemon = []
    for family_name, family_cards in sorted(
            evolution_families.items(),
            key=lambda x: get_type_index(x[1][0][0]),  # Use the type of the first card in the family
    ):
        sorted_pokemon.extend(family_cards)

    # Sort Trainers
    trainer_sort_order = ["Item", "Tool", "Supporter", "Stadium"]
    sorted_trainers = sorted(
        trainers.values(),
        key=lambda c: trainer_sort_order.index(c[0].subtypes[0])
        if c[0].subtypes and c[0].subtypes[0] in trainer_sort_order
        else float("inf"),
    )

    # Sort Energies
    sorted_energies = sorted(
        energies.values(),
        key=lambda c: 0 if c[0].subtypes and "Special" in c[0].subtypes[0] else 1,  # Special energies first
    )

    # Combine sorted cards
    return sorted_pokemon + sorted_trainers + sorted_energies


# Function to display multiple cards and allow adding them to the collection
def view_collection(cards_dict: dict[str, tuple[Card, int]]) -> None:
    sorted_cards = sort_cards(cards_dict)
    num_columns = 5
    columns = st.columns(num_columns)
    for idx, (card, quantity) in enumerate(sorted_cards):
        with columns[idx % num_columns]:
            st.image(card.images.large, use_container_width=True)
            button = st.button(f"Remove ({quantity} left)", key=f"{card.id}/{idx}", use_container_width=True)
            if button:
                remove_one_card_from_collection(card.id, st.session_state["name"])
                if quantity > 1:
                    cards_dict[card.id] = (card, quantity - 1)
                else:
                    cards_dict.pop(card.id)
                st.toast(f"Successfully removed {quantity} x '{card.name}'")
                st.rerun()


# Function to view cards
def view_cards() -> None:
    st.header("Your Cards", anchor=False)
    if not st.session_state.cards:
        st.warning("No cards available. Add some cards first!")
        return

    cards_dict: dict[str, tuple[Card, int]] = st.session_state.cards

    # Filtering options
    st.sidebar.header("Filter Options")

    # Filter by Rulebox
    non_rulebox = st.sidebar.checkbox("Non Rulebox Cards Only", value=False)
    if non_rulebox:
        cards_dict = {
            k: v for k, v in cards_dict.items() if not getattr(v[0], "rules", None)
        }

    # Filter by Supertype
    selected_supertypes = st.sidebar.multiselect(
        "Filter by Supertype", options=["Trainer", "Energy", "Pokémon"], default=[]
    )
    if selected_supertypes:
        cards_dict = {
            k: v for k, v in cards_dict.items() if v[0].supertype in selected_supertypes
        }

    # Filter by Pokémon Type (applies only to Pokémon cards)
    if "Pokémon" in selected_supertypes or not selected_supertypes:
        pokemon_types = [
            "Colorless",
            "Darkness",
            "Dragon",
            "Fairy",
            "Fighting",
            "Fire",
            "Grass",
            "Lightning",
            "Metal",
            "Psychic",
            "Water",
        ]
        selected_pokemon_types = st.sidebar.multiselect(
            "Filter by Pokémon Type", options=pokemon_types, default=[]
        )
        if selected_pokemon_types:
            cards_dict = {
                k: v
                for k, v in cards_dict.items()
                if v[0].supertype == "Pokémon"
                   and v[0].types
                   and v[0].types[0] in selected_pokemon_types
            }

    # Search by Name
    search_query = st.sidebar.text_input("Search by Name")
    if search_query:
        cards_dict = {
            k: v
            for k, v in cards_dict.items()
            if search_query.lower() in v[0].name.lower()
        }

    # Display filtered cards
    if not cards_dict:
        st.warning("No cards match the current filters.")
        return

    view_collection(cards_dict)
